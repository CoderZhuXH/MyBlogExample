atomic nonatomic区别
atomic：默认是有该属性的，这个属性是为了保证程序在多线程情况下，编译器会自动生成一些互斥加锁代码，避免该变量的读写不同步问题。
nonatomic：如果该对象无需考虑多线程的情况，请加入这个属性，这样会让编译器少生成一些互斥加锁代码，可以提高效率。
atomic的意思就是setter/getter这个函数，是一个原语操作。如果有多个线程同时调用setter的话，不会出现某一个线程执行完setter全部语句之前，另一个线程开始执行setter情况，相当于函数头尾加了锁一样，可以保证数据的完整性。nonatomic不保证setter/getter的原语行，所以你可能会取到不完整的东西。因此，在多线程的环境下原子操作是非常必要的，否则有可能会引起错误的结果。

比如setter函数里面改变两个成员变量，如果你用nonatomic的话，getter可能会取到只更改了其中一个变量时候的状态，这样取到的东西会有问题，就是不完整的。当然如果不需要多线程支持的话，用nonatomic就够了，因为不涉及到线程锁的操作，所以它执行率相对快些。

下面是载录的网上一段加了atomic的例子：

{lock}

if (property != newValue) {

[property release];

property = [newValue retain];

}

{unlock}

可以看出来，用atomic会在多线程的设值取值时加锁，中间的执行层是处于被保护的一种状态，atomic是oc使用的一种线程保护技术，基本上来讲，就是防止在写入未完成的时候被另外一个线程读取，造成数据错误。而这种机制是耗费系统资源的，所以在iPhone这种小型设备上，如果没有使用多线程间的通讯编程，那么nonatomic是一个非常好的选择。



使用@property声明属性时，经常用到atomic与nonatomic两个关键字，不写默认为atomic.
``objc

@property(nonatomic,copy)NSString *name;
@property(copy)NSString *address;

```

atomic与nonatomicd的主要区别就是系统自动生成的getter/setter方法不一样

atomic

系统生成的 getter/setter方法 会保证get、set操作的安全性,在别的线程来访问这个属性之前,会先执行完当前操作.


例如:
线程1调用了某一属性的setter方法并进行到了一半,线程2调用其getter方法,那么会执行完setter操作后,在执行getter操作,线程2会获取到线程1 setter后的完整的值.

注意: 当几个线程同时调用同一属性的setter、getter方法时,会get到一个完整的值,但get到的值不可控,例如:
线程1 调用getter
线程2 调用setter
线程3 调用setter
这3个线程并行同时开始,线程1会get到一个完整的值,但是这个值不可控,可能是线程2,线程3 set之前的原始值,可能是线程2 set的值,也可能是线程3 set的值


如果当一个线程正在get 或set时,又有另一个线程同时在进行 release 操作，那可能就会crash，因为 release 不受 getter/setter 操作的限制。也就是说，这个属性只能说是读/写安全的，但并不是线程安全的，因为别的线程还能进行读写之外的其他操作。

nonatomic
系统生成的getter/setter方法就不能保证get/set操作安全
线程不安全,但更快
当多个线程同时访问同一个属性，会出现无法预料的结果

下面通过简单的代码来演示下atomic和nonatomic实现原理

nonatomic

```objc

//interface

@property(nonatomic,copy)NSString *name;

```

```objc

//implementation

//set
-(void)setName:(NSString *)name
{
    if(_name != name)
    {
        [_name release];
        [_name retain];
        _name = name;
    }
}

//get
-(NSString *)name
{
   return _name;
}

```

atomic


